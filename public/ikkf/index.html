<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title> - insolubilia</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="&lt;!DOCTYPE html&gt; I-K-K-F-! Ready to start reading... HIGHLIGHTING 0 / 0 0:00 Go FILE Toggle option to select file (txt or epub) or paste text - Reduce WPM &#43; Increase WPM &gt; |&lt;&lt; Reset to start of text Arial Verdana Tahoma Times New Roman Georgia Consolas 2 Toggle 1-2-3 words shown at once V: Toggle view focus
H: Start/Stop highlighting
Space: Play/Pause
Left/right: Skip back or forward
F: Faster WPM" />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="" />
<meta property="og:description" content="&lt;!DOCTYPE html&gt; I-K-K-F-! Ready to start reading... HIGHLIGHTING 0 / 0 0:00 Go FILE Toggle option to select file (txt or epub) or paste text - Reduce WPM &#43; Increase WPM &gt; |&lt;&lt; Reset to start of text Arial Verdana Tahoma Times New Roman Georgia Consolas 2 Toggle 1-2-3 words shown at once V: Toggle view focus
H: Start/Stop highlighting
Space: Play/Pause
Left/right: Skip back or forward
F: Faster WPM" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://insolubilia.blog/ikkf/" /><meta property="article:section" content="" />



<meta name="twitter:card" content="summary"/><meta name="twitter:title" content=""/>
<meta name="twitter:description" content="&lt;!DOCTYPE html&gt; I-K-K-F-! Ready to start reading... HIGHLIGHTING 0 / 0 0:00 Go FILE Toggle option to select file (txt or epub) or paste text - Reduce WPM &#43; Increase WPM &gt; |&lt;&lt; Reset to start of text Arial Verdana Tahoma Times New Roman Georgia Consolas 2 Toggle 1-2-3 words shown at once V: Toggle view focus
H: Start/Stop highlighting
Space: Play/Pause
Left/right: Skip back or forward
F: Faster WPM"/>

        <link href="https://insolubilia.blog/css/fonts.3d086f03352af985d98029ce27bfce83fdcf3dc7e12df36a889f9b1b6d861d07.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://insolubilia.blog/css/main.4b31f8db406a7e9e835f100e8798a3956a0a4e7d98402d5ba5c5d2166c715f79.css" />
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://insolubilia.blog/">insolubilia</a>
		<div class="logo"><img src="https://insolubilia.blog/flammarion.png"></img></div>
	</div>
	<nav>
		
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title"></h1>
          <div class="meta">Updated on Jan 1, 1</div>
        </div>
        
        <section class="body">
          <!DOCTYPE html>
<html style="--accent: #1c71d8; --lightBG: #082241; --darkBG: #030b16;"><head>
<title>I-K-K-F-!</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Geany 2.0">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
:root {
    --text: #FFF;
    --lightBG: #0D3800;
    --darkBG: #071F00;
    --pageBG: #000;
    --accent: #16E937;
    --highlight: #F6D32D;
    --warning: #870000;
    --genericToggle: #a9a9a9;
    --fontSelect: "Arial";
    --outlineStyle: 1px dotted var(--accent);
    --hoverInd: brightness(1.5);
}

* {
    font-family: var(--fontSelect);
}

body {
    color: var(--text);
    background-color: var(--pageBG);
    margin: 0;
    padding: 0;
}

.main-container {
    display: flex;
    gap: 20px;
    position: relative;
    height: 95vh;
    width: 95vw;
    margin: 10px auto;
}

.panel {
    display: flex;
    flex-direction: column;
    position: relative;
    height: 100%;
    outline: var(--outlineStyle);
    background-color: var(--darkBG);
}

.left {
    display: flex;
    width: 75%;
}

.right {
    display: flex;
    width: 25%;
}

.controlbox {
    display: flex;
    flex-direction: column;
    height: 200px;
    padding: 10px;
}

.text-display {
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--chooseBG, --pageBG);
    color: var(--chooseTC, --text);
    min-height: 70%;
    position: relative;
}

.current-word {
    font-size: 3rem;
    font-weight: bold;
    text-align: center;
}

.epub-image {
    max-width: 90%;
    max-height: 80vh;
    object-fit: contain;
    cursor: pointer;
}

.image-caption {
    margin-top: 10px;
    font-size: 1rem;
    color: var(--text);
    text-align: center;
}

.epub-thumb {
    max-width: 120px;
    max-height: 90px;
    object-fit: contain;
    vertical-align: middle;
    margin: 4px;
}

.ctrl-col {
    display: flex;
    flex-direction: column;
    gap: 0;
}

.btn-compact {
    height: 15px;
    max-height: 15px;
    padding-top: 2px;
    padding-bottom: 2px;
    line-height: 1;
    box-sizing: border-box;
}


.highlight-indicator {
    position: absolute;
    top: 10px;
    right: 10px;
    outline: var(--outlineStyle);
    color: var(--highlight);
    padding: 5px 10px;
    font-size: 12px;
    display: none;
}

.highlight-indicator.active {
    display: block;
}

.progress-bar {
    width: 100%;
    height: 5px;
    background-color: var(--darkBG);
    overflow: hidden;
    margin-top: 10px;
}

.progress-fill {
    height: 100%;
    background-color: var(--accent);
    transition: width 0.3s;
}

.notes-list {
    position: relative;
    padding: 10px;
    height: 90%;
    overflow-y: auto;
    overflow-x: hidden;
    margin-bottom: 20px;
}

.note-item1, .note-item2 {
    background-color: var(--lightBG);
    padding: 0;
    outline: var(--outlineStyle);
    position: relative;
    margin-bottom: 10px;
}

.note-text {
    padding: 5px;
    color: var(--text);
}

.note-time {
    font-size: 10px;
    color: var(--genericToggle);
    padding-left: 5px;
}

.note-delete {
    background-color: var(--warning);
}

.row {
    display: flex;
    align-items: flex-start;
    align-content: center;
    width: 100%;
    gap: 10px;
    max-height: 75px;
    margin-bottom: 10px;
}

.center-align {
    align-items: center;
}

.right-align {
    margin-right: 0;
    margin-left: auto;
    justify-content: right;
}

.left-align {
    margin-left: 0;
    margin-right: auto;
    flex: 1;
}

.switch-box {
    position: relative;
    width: 60px;
    height: 20px;
    outline: var(--outlineStyle);
    background-color: var(--pageBG);
}

.ontop {
    margin: 10px 0 0 10px;
    position: absolute;
}

.switch-box input {
    display: none;
    width: 60px;
    height: 20px;
}

.slider {
    position: absolute;
    cursor: pointer;
    content: "";
    height: 20px;
    background-color: var(--lightBG);
    transition: .4s;
}

.file-or-copy {
    position: relative;
    left: 0;
    width: 30px;
}

.view-toggle {
    left: 15px;
}

.slider:hover {
    filter: var(--hoverInd);
}

.label {
    font-size: 10px;
    width: 30px;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
}

input[type=file] {
    display: block;
    border: none;
    background-color: var(--darkBG);
    max-width: 500px;
    overflow-x: hidden;
}

input[type="range"] {
    width: 150px;
    flex-shrink: 1;
    accent-color: var(--accent);
}

input[type="color"] {
    width: 50px;
    height: 30px;
    cursor: pointer;
    background-color: var(--darkBG);
    outline: var(--outlineStyle);
    border: none;
}

.text-input {
    display: flex;
    flex: 1;
    width: 80%;
    margin-bottom: 10px;
    height: 31px;
}

.paste-text {
    display: none;
    padding: 0;
    width: 80%;
    height: 31px;
    margin-bottom: 10px;
}

.edit-textarea {
    width: 90%;
}

textarea {
    flex: 1;
    overflow-y: scroll;
    padding: 5px;
    border: none;
    background-color: var(--pageBG);
    color: var(--text);
    outline: var(--outlineStyle);
}

.button {
    display: flex;
    padding: 5px;
    border: none;
    outline: var(--outlineStyle);
    cursor: pointer;
    font-size: 10px;
    font-weight: bold;
    width: 30px;
    height: 30px;
    text-align: center;
    align-items: center;
    justify-content: center;
    background-color: var(--lightBG);
    color: var(--text);
}

.button:hover {
    filter: var(--hoverInd);
}

.pasteButton {
    display: none;
}

.delete {
    background-color: var(--warning);
}

.status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    background-color: var(--lightBG);
    margin-top: 10px;
    color: var(--text);
}

select {
    display: flex;
    padding: 0px;
    height: 20px;
    margin: 10px 0px;
    background-color: var(--lightBG);
    color: var(--text);
    border: none;
    outline: 1px dotted var(--accent);
}

option {
    background-color: var(--lightBG);
    border: 1px solid var(--accent);
    color: var(--text);
    outline: none;
}

.wpm-control {
    display: flex;
    align-items: center;
    gap: 0px;
}

.wpm-input {
    width: 60px;
    height: 28px;
    text-align: center;
    background-color: var(--darkBG);
    color: var(--text);
    outline: none;
    border: var(--outlineStyle);
    font-size: 12px;
}

.instructions {
    color: var(--genericToggle);
    font-size: 10px;
}

.tooltiptext {
    visibility: hidden;
    background-color: var(--pageBG);
    border: 1px dotted var(--accent);
    color: var(--accent);
    width: 250px;
    font-size: 12px;
    height: auto;
    text-align: center;
    padding: 5px 0;
    position: absolute;
    z-index: 1;
    top: -5px;
    left: 105%;
}

label:hover .tooltiptext,
.button:hover .tooltiptext,
input:hover .tooltiptext {
    visibility: visible;
    transition-delay: 2s;
}
</style>
</head>
<body>
<div class="main-container">
<div class="panel left">
    <div class="text-display" id="textDisplay" style="--chooseTC: #9a9996; --chooseBG: #000000;">
        <div class="current-word" id="currentWord">Ready to start reading...</div>
        <div class="highlight-indicator" id="highlightIndicator">HIGHLIGHTING</div>
    </div>
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
    </div>
    <div class="status-bar">
        <span id="positionInfo">0 / 0</span>
        <span id="timeInfo">0:00</span>
    </div>
    <div class="controlbox">
        <div class="row left-align">
            <div class="file input">
                <input type="file" id="fileInput" accept=".txt,.epub" style="display: flex;">
            </div>
            <div class="paste-text" style="display: none;">
                <textarea placeholder="Paste text..." id="pasteText"></textarea>
            </div>
            <button class="button pasteButton" id="pasteTextInput" onclick="pasteText()" style="display: none;">Go</button>
            <label class="switch-box right-align">
                <input type="checkbox" onclick="inputType()">
                <span class="label slider file-or-copy" id="inputType" style="transform: translateX(0px);">FILE</span>
                <span class="tooltiptext">Toggle option to select file (txt or epub) or paste text</span>
            </label>
        </div>
        <div class="row left-align center-align" style="flex-wrap:wrap">
            <div class="wpm-control">
                <button class="button" id="wpmMinus">-
                    <span class="tooltiptext">Reduce WPM</span>
                </button>
                <input type="text" id="wpmInput" class="wpm-input" placeholder="390">
                <button class="button" id="wpmPlus">+
                    <span class="tooltiptext">Increase WPM</span>
                </button>
            </div>
            <button class="button" id="playPauseButton">&gt;</button>
            <button class="button" id="resetbutton">|&lt;&lt;
                <span class="tooltiptext">Reset to start of text</span>
            </button>
            <input title="Text color" type="color" id="textColor" value="#9a9996">
            <input title="Background color" type="color" id="bgColor" value="#000000">
            <input title="Theme color" type="color" id="schemeColor" value="#1c71d8">
            <select name="fontChoose" id="fontChoose">
                <option style="font-family:arial" value="arial" selected="selected">Arial</option>
                <option style="font-family:verdana" value="verdana">Verdana</option>
                <option style="font-family:Tahoma" value="Tahoma">Tahoma</option>
                <option style="font-family:TimesNewRoman" value="TimesNewRoman">Times New Roman</option>
                <option style="font-family:Georgia" value="Georgia">Georgia</option>
                <option style="font-family:Consolas" value="Consolas">Consolas</option>
            </select>
            <label class="switch-box">
                <input type="checkbox" onclick="howManyWordsFunc()">
                <span class="label slider word-select" id="wordCountSlider" style="transform: translateX(15px);">2</span>
                <span class="tooltiptext">Toggle 1-2-3 words shown at once</span>
            </label>
            <span class="instructions">
                V: Toggle view focus<br>
                H: Start/Stop highlighting<br>
            </span>
            <span class="instructions">
                Space: Play/Pause<br>
                Left/right: Skip back or forward<br>
            </span>    
            <span class="instructions">
                F: Faster WPM<br>
                S: Slower WPM<br>
                Hover to get a tooltip<br>
            </span>
        </div>
    </div>
</div>
<div class="panel right">
    <div class="controlbox">
        <div class="row right-align">
            <button class="button delete" id="clearNotesbutton">DEL ALL</button>
            <button class="button" id="saveNotesbutton">SAVE .MD
                <span class="tooltiptext">Will save as .zip with images and .md if images are highlighted</span>
            </button>
        </div>
        <div class="row right-align">
            <div class="text-input">
                <textarea placeholder="Add custom note..." id="manualNote"></textarea>
            </div>
            <button class="button" id="submitManualNote" onclick="createManualNote()">+</button>
        </div>
    </div>
    <div class="notes-list" id="notesList">
        <div style="color: #888; text-align: center; padding: 20px;">Notes go here...</div>
    </div>
</div>
<label class="switch-box ontop">
    <input type="checkbox" onclick="noteFocus()">
    <span class="label slider view-toggle" id="viewSlider">V</span>
    <span class="tooltiptext">Toggle focus on reading or note panes</span>
</label>
</div>

<script>
let words = [];
let currentPos = 0;
let isPlaying = false;
let wpm = 390;
let notes = [];
let isHighlighting = false;
let highlightStart = 0;
let currentFileName = '';
let playTimeoutId = null;
let size = 0;
let fileToggle = 0;
let howManyWords = 2;
let count = 1;
let epubImages = {};

const elements = {
    fileInput: document.getElementById('fileInput'),
    wpmInput: document.getElementById('wpmInput'),
    wpmPlus: document.getElementById('wpmPlus'),
    wpmMinus: document.getElementById('wpmMinus'),
    playPauseButton: document.getElementById('playPauseButton'),
    resetbutton: document.getElementById('resetbutton'),
    textColor: document.getElementById('textColor'),
    bgColor: document.getElementById('bgColor'),
    schemeColor: document.getElementById('schemeColor'),
    textDisplay: document.getElementById('textDisplay'),
    currentWord: document.getElementById('currentWord'),
    highlightIndicator: document.getElementById('highlightIndicator'),
    
    progressFill: document.getElementById('progressFill'),
    positionInfo: document.getElementById('positionInfo'),
    timeInfo: document.getElementById('timeInfo'),
    notesList: document.getElementById('notesList'),
    saveNotesbutton: document.getElementById('saveNotesbutton'),
    clearNotesbutton: document.getElementById('clearNotesbutton'),
    fontMenu: document.getElementById('fontChoose'),
};

// File upload
elements.fileInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        if (file.type === 'text/plain') {
            elements.loadingOverlay.style.display = 'none';
            currentFileName = file.name.replace('.txt', ''); 
            const reader = new FileReader();
            reader.onload = function(e) {
                loadText(e.target.result);
            };
            reader.readAsText(file);
        } else if (file.name.endsWith('.epub')) {
            elements.currentWord.textContent = 'Loading EPUB…';
            currentFileName = file.name.replace('.epub', '');
            loadEpub(file);
        } else {
            alert('Please upload a .txt or .epub file');
        }
    }
});

function inputType() {
    if (fileToggle < 1) {
        fileToggle++;
    } else {
        fileToggle = 0;
    }
    var pasteInput = document.querySelector('.paste-text');
    var pasteButton = document.querySelector('.pasteButton');
    var sliderBar = document.getElementById('inputType');
    
    if (fileToggle === 0) {
        fileInput.style.display = "flex";
        pasteInput.style.display = "none";
        pasteButton.style.display = "none";
        sliderBar.style.transform = "translateX(0px)";
        sliderBar.textContent = 'FILE';
    } else {
        fileInput.style.display = "none";
        pasteInput.style.display = "flex";
        pasteButton.style.display = "flex";
        sliderBar.style.transform = "translateX(30px)";
        sliderBar.textContent = 'PASTE';
    }
}

function pasteText() {
    var text = document.getElementById("pasteText").value;
    loadText(text);
}


// Fonts
elements.fontMenu.addEventListener('change', function(e) {
    const root = document.documentElement;
    fontSelect = document.getElementById('fontChoose').value;
    root.style.setProperty('--fontSelect', fontSelect);
});

// Speed control
elements.wpmInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        const newWpm = parseInt(e.target.value);
        if (!isNaN(newWpm) && newWpm >= 50 && newWpm <= 2000) {
            wpm = newWpm;
            elements.wpmInput.placeholder = wpm;
            if (isPlaying) {
                currentPos--;
                restartPlayback();
            }
        }
        elements.wpmInput.value = '';
        elements.wpmInput.blur();
    }
});

elements.wpmPlus.addEventListener('click', function() {
    wpm = Math.min(wpm + 10, 2000);
    elements.wpmInput.placeholder = wpm;
    if (isPlaying) {
        currentPos--;
        restartPlayback();
    }
});

elements.wpmMinus.addEventListener('click', function() {
    wpm = Math.max(wpm - 10, 50);
    elements.wpmInput.placeholder = wpm;
    if (isPlaying) {
        currentPos--;
        restartPlayback();
    }
});

// User control stuff
elements.playPauseButton.addEventListener('click', togglePlayPause);
elements.resetbutton.addEventListener('click', resetReading);
elements.textColor.addEventListener('change', updateColors);
elements.bgColor.addEventListener('change', updateColors);
elements.schemeColor.addEventListener('change', updateColors);
elements.saveNotesbutton.addEventListener('click', saveNotes);
elements.clearNotesbutton.addEventListener('click', clearAllNotes);

function howManyWordsFunc() {
    var sliderBarWordCount = document.getElementById('wordCountSlider');
    if (count < 2) {
        count++;
    } else {
        count = 0;
    }

    if (count === 0) {
        howManyWords = 1;
        sliderBarWordCount.style.transform = "translateX(0px)";
        sliderBarWordCount.textContent = '1';              
    } else if (count === 1) {
        howManyWords = 2; 
        sliderBarWordCount.style.transform = "translateX(15px)";
        sliderBarWordCount.textContent = '2';          
    } else if (count === 2) {
        howManyWords = 3; 
        sliderBarWordCount.style.transform = "translateX(30px)";
        sliderBarWordCount.textContent = '3';              
    }
}

function noteFocus() {
    //checkbox misbehaving
    if (size < 3) {
        size++;
    } else {
        size = 0;
    }
    var sliderBar = document.getElementById("viewSlider");
    var rightPanel = document.querySelector(".right");
    var leftPanel = document.querySelector(".left");
    var rows = document.querySelector(".controlbox");
    
    if (size === 1) {  
        rightPanel.style.display = "none";
        rows.style.display = "none";
        leftPanel.style.display = "flex";
        leftPanel.style.width = "100%";
        sliderBar.style.transform = "translateX(15px)";
    } else if (size === 2) {
        leftPanel.style.display = "flex";
        rightPanel.style.display = "flex";
        rows.style.display = "flex";                
        leftPanel.style.width = "75%";
        rightPanel.style.backgroundColor = "var(--darkBG)";                
        sliderBar.style.transform = "translateX(0px)";
    } else if (size === 3) {
        leftPanel.style.display = "none";
        rightPanel.style.display = "flex";
        rightPanel.style.width = "100%";
        rightPanel.style.backgroundColor = "var(--pageBG)";
        sliderBar.style.transform = "translateX(-15px)";
    } else {
        leftPanel.style.display = "flex";
        leftPanel.style.width = "75%";
        rightPanel.style.display = "flex";
        rightPanel.style.width = "25%";
        rightPanel.style.backgroundColor = "var(--darkBG)";
        sliderBar.style.transform = "translateX(0px)";
    }
}

function createManualNote() {
    var noteContent = document.getElementById("manualNote").value;
    addNote(noteContent, 0, 0, 2);
    document.getElementById("manualNote").value = "";
}


// keyboard shortcuts
document.addEventListener('keydown', function(e) {
    var notes = document.getElementById("manualNote");
    var pasteInput = document.getElementById("pasteText");
    var noteEdit = document.getElementById("editText");
    var wpmInput = document.getElementById("wpmInput");
    var isTyping = ((document.activeElement === notes) || (document.activeElement === pasteInput) || (document.activeElement === wpmInput) || (document.activeElement === noteEdit));
    var notesCheck = (document.activeElement === notes);
    var pasteInputCheck = (document.activeElement === pasteInput);
    
    if (!isTyping) {
        if (e.key === 'h') {
            e.preventDefault();
            toggleHighlight();
        } else if (e.key === ' ') {
            e.preventDefault();
            togglePlayPause();
        } else if (e.key === 'v') {
            e.preventDefault();
            noteFocus();                
        } else if (e.key === 'f') {
            e.preventDefault();
            wpm = Math.min(wpm + 10, 2000);
            elements.wpmInput.placeholder = wpm;
            if (isPlaying) {
                currentPos--;
                restartPlayback();
            }
        } else if (e.key === 's') {
            e.preventDefault();
            wpm = Math.max(wpm - 10, 50);
            elements.wpmInput.placeholder = wpm;
            if (isPlaying) {
                currentPos--;
                restartPlayback();
            }
        } else if (e.key === "ArrowLeft") {
            e.preventDefault();
            if (currentPos > 15) {
                currentPos = (currentPos - 15);
            } else {
                currentPos = 0;
            }
            if (!isPlaying) {
                elements.currentWord.textContent = words[currentPos] || 'Ready to start reading...';
                updateDisplay();
            }
        } else if (e.key === "ArrowRight") {
            e.preventDefault();
            if (currentPos < (words.length - 15)) {
                currentPos = (currentPos + 15);
            }
            if (!isPlaying) {
                elements.currentWord.textContent = words[currentPos] || 'Ready to start reading...';
                updateDisplay();
            }
        }
    } else {
        if ((e.key === 'Enter') && (notesCheck)) {
            e.preventDefault();
            createManualNote();
        }
        if ((e.key === 'Enter') && (pasteInputCheck)) {
            e.preventDefault();
            pasteText();
        }
    }
});

function loadText(text, resetImages = true) {
    text = text.trim().replace(/\s+/g, ' ');
    words = text.split(' ').filter(word => word.length > 0);
    currentPos = 0;
    if (resetImages) {
        epubImages = {};
    }
    updateDisplay();
    elements.currentWord.textContent = 'Ready to start reading...';
    elements.playPauseButton.disabled = false;
}

async function loadEpub(file) {
    try {
        const arrayBuffer = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(arrayBuffer);
        
        const containerXml = await zip.file('META-INF/container.xml').async('text');
        const opfPath = containerXml.match(/full-path="([^"]+)"/)[1];
        const opfDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);
        
        const opfContent = await zip.file(opfPath).async('text');
        const parser = new DOMParser();
        const opfDoc = parser.parseFromString(opfContent, 'text/xml');
        
        const spineItems = Array.from(opfDoc.querySelectorAll('spine itemref')).map(
            item => item.getAttribute('idref')
        );
        
        const manifestItems = {};
        opfDoc.querySelectorAll('manifest item').forEach(item => {
            manifestItems[item.getAttribute('id')] = item.getAttribute('href');
        });
        
        let fullText = '';
        let wordCount = 0;
        epubImages = {};
        
        for (const itemId of spineItems) {
            const href = manifestItems[itemId];
            if (!href) continue;
            
            const filePath = opfDir + href;
            const htmlContent = await zip.file(filePath).async('text');
            const doc = parser.parseFromString(htmlContent, 'text/html');
            
            const images = doc.querySelectorAll('img');
            for (const img of images) {
                const imgSrc = img.getAttribute('src');
                if (imgSrc) {
                    const currentDir = filePath.substring(0, filePath.lastIndexOf('/') + 1);
                    let imgPath = imgSrc;
                    if (imgSrc.startsWith('../')) {
                        const upLevels = (imgSrc.match(/\.\.\//g) || []).length;
                        let baseDir = currentDir;
                        for (let i = 0; i < upLevels; i++) {
                            baseDir = baseDir.substring(0, baseDir.lastIndexOf('/', baseDir.length - 2) + 1);
                        }
                        imgPath = baseDir + imgSrc.replace(/\.\.\//g, '');
                    } else if (!imgSrc.startsWith('/')) {
                        imgPath = currentDir + imgSrc;
                    } else {
                        imgPath = imgSrc.substring(1);
                    }
                    
                    try {
                        let imgFile = zip.file(imgPath);
                        if (!imgFile) {
                            const imgFileName = imgSrc.split('/').pop();
                            const allFiles = Object.keys(zip.files);
                            for (const fileName of allFiles) {
                                if (fileName.endsWith(imgFileName)) {
                                    imgFile = zip.file(fileName);
                                    break;
                                }
                            }
                        }
                        
                        if (imgFile) {
                            const imgData = await imgFile.async('base64');
                            const imgExt = imgPath.split('.').pop().toLowerCase();
                            const mimeType = imgExt === 'png' ? 'image/png' : 
                                            imgExt === 'jpg' || imgExt === 'jpeg' ? 'image/jpeg' : 
                                            imgExt === 'gif' ? 'image/gif' : 
                                            imgExt === 'svg' ? 'image/svg+xml' : 'image/png';

                            const imgId = `img_${Object.keys(epubImages).length}`;
                            epubImages[imgId] = { src: `data:${mimeType};base64,${imgData}`, alt: img.getAttribute('alt') || '' };

                            img.replaceWith(document.createTextNode(` [IMAGE:${imgId}] `));
                        } else {
                            console.log('Image file not found:', imgPath);
                        }
                    } catch (e) {
                        console.log('Could not load image:', imgPath, e);
                    }
                }
            }
            
            doc.querySelectorAll('script, style').forEach(el => el.remove());
            
            const text = doc.body ? doc.body.textContent : doc.textContent;
            const cleanText = text.replace(/\s+/g, ' ').trim();
            
            if (cleanText) {
                fullText += ' ' + cleanText;
                wordCount += cleanText.split(' ').length;
            }
        }
        
        loadText(fullText, false);
        elements.currentWord.textContent = 'Ready to start reading...';
        
    } catch (error) {
        console.error('Error loading EPUB:', error);
        alert('Error loading EPUB file. Please make sure it is a valid EPUB.');
        elements.currentWord.textContent = 'Ready to start reading...';
    }
}

function togglePlayPause() {
    if (words.length === 0) return;
    if (isPlaying) {
        pauseReading();
    } else {
        startReading();
    }
}

function startReading() {
    if (words.length === 0) return;
    isPlaying = true;
    elements.playPauseButton.textContent = '||';
    if (playTimeoutId) {
        clearTimeout(playTimeoutId);
        playTimeoutId = null;
    }
    scheduleNextWord();
}

function scheduleNextWord() {
    if (!isPlaying) return;
    
    if (currentPos >= words.length) {
        pauseReading();
        return;
    }

    let endSlice = currentPos + howManyWords;
    const wordSlice = words.slice(currentPos, endSlice);

    // Show pics
    const imageTokenIndex = wordSlice.findIndex(w => /\[IMAGE:([^\]]+)\]/.test(w));
    if (imageTokenIndex !== -1) {
        const token = wordSlice[imageTokenIndex];
        const match = token.match(/\[IMAGE:([^\]]+)\]/);
        if (match) {
            const imageId = match[1];
            displayImageById(imageId);
            currentPos = currentPos + imageTokenIndex + 1; 
            updateDisplay();
            return;
        }
    }

    const displayWords = wordSlice.filter(w => !w.includes('[IMAGE:'));

    if (displayWords.length > 0) {
        elements.currentWord.textContent = displayWords.join(' ');
    }
    
    const baseDelay = 60000 / wpm; 
    const currentWord = displayWords.join(' ');
        
    let totalDelay = baseDelay;
    if (shouldPauseAfterWord(currentWord)) {
        totalDelay = baseDelay + 150;
    }
    
    currentPos = currentPos + howManyWords;
    updateDisplay();
    playTimeoutId = setTimeout(scheduleNextWord, totalDelay);
}

function displayImageById(imageId) {
    pauseReading();
    const meta = epubImages[imageId];
    if (meta && meta.src) {
        elements.currentWord.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center;">
                <img src="${meta.src}" class="epub-image" alt="${meta.alt || ''}" onclick="resumeFromImage()">
                ${meta.alt ? `<div class=\"image-caption\">${meta.alt}</div>` : ''}
                <div class="image-caption" style="margin-top: 20px; color: var(--accent);">Click image or press Space to continue</div>
            </div>
        `;
    }
}

function resumeFromImage() {
    if (!isPlaying) {
        startReading();
    }
}

function shouldPauseAfterWord(word) {
    if (!word || word.length === 0) return false;
    if (word.length > 10) return true;
    const quotePattern = /\p{P}/gu;
    if (quotePattern.test(word)) {
        return true;
    }
    return false;
}

function pauseReading() {
    isPlaying = false;
    elements.playPauseButton.textContent = '>';
    if (playTimeoutId) {
        clearTimeout(playTimeoutId);
        playTimeoutId = null;
    }
}

function resetReading() {
    pauseReading();
    currentPos = 0;
    elements.currentWord.textContent = 'Ready to start reading...';
    updateDisplay();
}

function restartPlayback() {
    if (isPlaying) {
        pauseReading();
        startReading();
    }
}

function toggleHighlight() {
    if (words.length === 0) return;
    
    if (!isHighlighting) {
        startHighlight();
    } else {
        endHighlight();
    }
}

function startHighlight() {
    isHighlighting = true;
    highlightStart = findSentenceStart(Math.max(0, currentPos - 1));
    elements.highlightIndicator.classList.add('active');
}

function endHighlight() {
    if (!isHighlighting) return;
    
    isHighlighting = false;
    elements.highlightIndicator.classList.remove('active');
    
    let highlightEnd = findSentenceStart(Math.max(0, currentPos - 1));

    if (highlightStart < highlightEnd) {
        const highlightedText = words.slice(highlightStart, highlightEnd).join(' ');
        addNote(highlightedText, highlightStart, highlightEnd, 1);
    }
    if (highlightStart === highlightEnd) {
        const highlightedText = words.slice(highlightStart, currentPos).join(' ');
        addNote(highlightedText, highlightStart, currentPos, 1);
    }
}

function findSentenceStart(index) {
    if (index <= 0) return 0;
    
    for (let i = index - 1; i >= 0; i--) {
        const word = words[i];
        if (word.endsWith('.') || word.endsWith('!') || word.endsWith('?')) {
            return (Math.min(i + 1, words.length - 1));
        }
    }
    return 0;
}

function addNote(text, start, end, type) {
    const note = {
        id: Date.now(), 
        text: text,
        timestamp: new Date().toLocaleString(),
        start: start,
        end: end,
        type: type
    };
    if (text.length > 0) {
        notes.push(note);
        updateNotesList(start, end, type);
    }
}

function deleteNote(noteId) {
    notes = notes.filter(note => note.id !== noteId);
    updateNotesList();
}

function clearAllNotes() {
    if (notes.length === 0) {
        alert('No notes to clear');
        return;
    }
    
    if (confirm('Are you sure you want to delete all notes?')) {
        notes = [];
        updateNotesList();
    }
}

function editNote(noteId) {
    const note = findNoteById(noteId);
    if (!note) return;
    
    const noteElement = document.querySelector(`[data-note-id="${noteId}"]`);
    if (!noteElement) return;
    
    const textDiv = noteElement.querySelector('.note-text');
    const originalText = note.text;
    
    textDiv.innerHTML = `<textarea class="edit-textarea" id="editText" style="min-height: 60px; resize: vertical; padding: 5px; border: 1px solid var(--accent);">${escapeHtml(originalText)}</textarea>`;
    
    const buttonContainer = noteElement.querySelector('.row.right-align');
    buttonContainer.innerHTML = `
        <button class="button" onclick="saveEditedNote(${noteId})">SAVE</button>
        <button class="button note-delete delete" onclick="cancelEdit(${noteId})">BACK</button>
    `;
}

function saveEditedNote(noteId) {
    const note = findNoteById(noteId);
    if (!note) return;
    
    const noteElement = document.querySelector(`[data-note-id="${noteId}"]`);
    const textarea = noteElement.querySelector('.edit-textarea');
    const newText = textarea.value.trim();
    
    if (newText.length === 0) {
        alert('Note cannot be empty');
        return;
    }

    note.text = newText;
    note.timestamp = new Date().toLocaleString();   
    updateNotesList();
}

function cancelEdit(noteId) {
    updateNotesList();
}

function updateNotesList(start, end, type) {
    if (notes.length === 0) {
        elements.notesList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">Notes go here...</div>';
        return;
    }
    
    elements.notesList.innerHTML = notes.map(note => {
        const renderedHtml = renderNoteTextWithImages(note.text);
        if (note.type === 1) {
            return `<div class="note-item1" data-note-id="${note.id}">` +
                '<div class="note-text">' + renderedHtml + '</div>' +
                '<div class="note-time">' + note.timestamp + '</div>' +
                '<br>' +
                '<div class="row right-align" style="gap:12px; align-items: stretch;">' +
                    '<div class="ctrl-col">' +
                        '<button class="button btn-compact" onclick="leftSentence(' + note.id + ')"><<</button>' +
                        '<button class="button note-delete delete btn-compact" onclick="trimStartSentence(' + note.id + ')">>></button>' +
                    '</div>' +
                    '<div class="ctrl-col">' +
                        '<button class="button btn-compact" onclick="leftWord(' + note.id + ')"><</button>' +
                        '<button class="button note-delete delete btn-compact" onclick="trimStartWord(' + note.id + ')">></button>' +
                    '</div>' +
                    '<div class="ctrl-col">' +
                        '<button class="button btn-compact" onclick="rightWord(' + note.id + ')">></button>' +
                        '<button class="button note-delete delete btn-compact" onclick="trimEndWord(' + note.id + ')"><</button>' +
                    '</div>' +
                    '<div class="ctrl-col">' +
                        '<button class="button btn-compact" onclick="rightSentence(' + note.id + ')">>></button>' +
                        '<button class="button note-delete delete btn-compact" onclick="trimEndSentence(' + note.id + ')"><<</button>' +
                    '</div>' +
                    '<div class="ctrl-col">' +
                        '<button class="button note-delete delete" onclick="deleteNote(' + note.id + ')">×</button>' +
                    '</div>' +
                '</div>' +    
                '</div>';
        } else if (note.type === 2) {
            return `<div class="note-item2" data-note-id="${note.id}">` +
                '<div class="note-text">' + renderedHtml + '</div>' +
                '<div class="note-time">' + note.timestamp + '</div>' +
                '<br>' +
                '<div class="row right-align">' +
                '<button class="button" onclick="editNote(' + note.id + ')">EDIT</button>' +
                '<button class="button note-delete delete" onclick="deleteNote(' + note.id + ')">×</button>' +
                '</div>' +    
                '</div>';
        }
    }).join('');
}

function renderNoteTextWithImages(text) {
    const escaped = escapeHtml(text);
    return escaped.replace(/\[IMAGE:([^\]]+)\]/g, function(_, id) {
        const meta = epubImages[id];
        if (!meta || !meta.src) return '';
        const alt = (meta.alt || '').replace(/["<>]/g, '');
        return '<img class="epub-thumb" src="' + meta.src + '" alt="' + alt + '">';
    });
}

function findNoteById(noteId) {
    return notes.find(note => note.id === noteId);
}

function updateNoteText(noteId, newStart, newEnd) {
    const note = findNoteById(noteId);
    if (!note) return;
    note.start = newStart;
    note.end = newEnd;
    note.text = words.slice(newStart, newEnd + 1).join(' ');
    updateNotesList();
}

function leftSentence(noteId) {
    const note = findNoteById(noteId);
    if (!note) return;
    let searchStart = Math.max(0, note.start - 1);
    if (searchStart === note.start) return;
    let newStart = searchStart; 
    for (let i = searchStart - 1; i >= 0; i--) {
        const word = words[i];
        if (isSentenceEnd(word)) {
            const sentenceStart = Math.max(0, i + 1);
            if (sentenceStart < note.start) {
                newStart = sentenceStart;
            }
            break;
        }
        if (i === 0) {
            newStart = 0;
        }
    }
    updateNoteText(noteId, newStart, note.end);
}

function leftWord(noteId) {
    const note = findNoteById(noteId);
    if (!note) return;
    const newStart = Math.max(0, note.start - 1);
    if (newStart !== note.start) {
        updateNoteText(noteId, newStart, note.end);
    }
}

function rightWord(noteId) {
    const note = findNoteById(noteId);
    if (!note) return;
    const newEnd = Math.min(words.length - 1, note.end + 1);
    if (newEnd !== note.end) {
        updateNoteText(noteId, note.start, newEnd);
    }
}

function rightSentence(noteId) {
    const note = findNoteById(noteId);
    if (!note) return;
    
    let newEnd = note.end;
    if (newEnd >= words.length - 1) return;
    for (let i = newEnd + 1; i < words.length; i++) {
        const word = words[i];
        if (isSentenceEnd(word)) {
            newEnd = i;
            break;
        }
        if (i === words.length - 1) {
            newEnd = words.length - 1;
        }
    }
    
    updateNoteText(noteId, note.start, newEnd);
}

function trimStartWord(noteId) {
    const note = findNoteById(noteId);
    if (!note) return;
    if (note.start >= note.end) return;
    const newStart = Math.min(note.end, note.start + 1);
    updateNoteText(noteId, newStart, note.end);
}

function trimEndWord(noteId) {
    const note = findNoteById(noteId);
    if (!note) return;
    if (note.end <= note.start) return;
    const newEnd = Math.max(note.start, note.end - 1);
    updateNoteText(noteId, note.start, newEnd);
}

function trimStartSentence(noteId) {
    const note = findNoteById(noteId);
    if (!note) return;
    if (note.start >= note.end) return;
    let i = note.start;
    while (i < note.end) {
        if (isSentenceEnd(words[i])) {
            const newStart = Math.min(note.end, i + 1);
            updateNoteText(noteId, newStart, note.end);
            return;
        }
        i++;
    }
    updateNoteText(noteId, note.end, note.end);
}

function trimEndSentence(noteId) {
    const note = findNoteById(noteId);
    if (!note) return;
    if (note.end <= note.start) return;
    let i = note.end - 1;
    while (i > note.start) {
        if (isSentenceEnd(words[i])) {
            const newEnd = i;
            updateNoteText(noteId, note.start, newEnd);
            return;
        }
        i--;
    }
    updateNoteText(noteId, note.start, note.start);
}

function isSentenceEnd(word) {
    const cleanWord = word.replace(/["'""'']+$/g, '');
    return cleanWord.endsWith('.') || cleanWord.endsWith('!') || cleanWord.endsWith('?');
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function updateColors() {
    const textColor = elements.textColor.value;
    const bgColor = elements.bgColor.value;
    const schemeColor = elements.schemeColor.value;
    const root = document.documentElement; 
    
    elements.textDisplay.style.setProperty('--chooseTC', textColor);
    elements.textDisplay.style.setProperty('--chooseBG', bgColor);
    root.style.setProperty('--accent', schemeColor);
    var newLight = ColorLuminance(schemeColor, -0.7);
    var newDark = ColorLuminance(schemeColor, -0.9);
    root.style.setProperty('--lightBG', newLight);
    root.style.setProperty('--darkBG', newDark);
}

//add matching color scheme https://www.sitepoint.com/javascript-generate-lighter-darker-color/
function ColorLuminance(hex, lum) {
    hex = String(hex).replace(/[^0-9a-f]/gi, '');
    if (hex.length < 6) {
        hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
    }
    lum = lum || 0;

    var rgb = "#", c, i;
    for (i = 0; i < 3; i++) {
        c = parseInt(hex.substr(i*2,2), 16);
        c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
        rgb += ("00"+c).substr(c.length);
    }

    return rgb;
}

async function updateDisplay() {
    const progress = words.length > 0 ? (currentPos / words.length) * 100 : 0;
    elements.progressFill.style.width = progress + '%';
    elements.positionInfo.textContent = currentPos + ' / ' + words.length;
    
    if (words.length > 0) {
        const wordsRemaining = words.length - currentPos;
        const timeRemaining = (wordsRemaining / wpm) * 60;
        const minutes = Math.floor(timeRemaining / 60);
        const seconds = Math.floor(timeRemaining % 60);
        elements.timeInfo.textContent = minutes + ':' + seconds.toString().padStart(2, '0');
    } else {
        elements.timeInfo.textContent = '--:--';
    }
}

function saveNotes() {
    if (notes.length === 0) {
        alert('No notes to save');
        return;
    }

    const allNotesText = notes.map(note => note.text).join('\n');
    const imageIdSet = extractImageIdsFromText(allNotesText);

    const markdownText = notes.map(note => replaceImageTokensForMarkdown(note.text)).join('\n\n\n');

    let baseName = 'rsvp-notes';
    if (currentFileName) {
        baseName = currentFileName + '-notes';
    }

    if (imageIdSet.size > 0) {
        const zip = new JSZip();
        zip.file('highlights.md', markdownText);
        const imagesFolder = zip.folder('images');

        imageIdSet.forEach((imageId) => {
            const meta = epubImages[imageId];
            if (!meta || !meta.src) return;
            const match = meta.src.match(/^data:([^;]+);base64,(.*)$/);
            if (!match) return;
            const mimeType = match[1];
            const base64Data = match[2];
            const ext = getImageExtensionFromMime(mimeType);
            const fileName = imageId + '.' + ext;
            imagesFolder.file(fileName, base64Data, { base64: true });
        });

        zip.generateAsync({ type: 'blob' }).then((content) => {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = baseName + '.zip';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
    } else {
        const blob = new Blob([markdownText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = baseName + '.md';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
}

function extractImageIdsFromText(text) {
    const ids = new Set();
    const regex = /\[IMAGE:([^\]]+)\]/g;
    let match;
    while ((match = regex.exec(text)) !== null) {
        ids.add(match[1]);
    }
    return ids;
}

function replaceImageTokensForMarkdown(text) {
    return text.replace(/\[IMAGE:([^\]]+)\]/g, function(_, id) {
        const meta = epubImages[id];
        if (!meta || !meta.src) return '';
        const mimeMatch = meta.src.match(/^data:([^;]+);base64,/);
        const mimeType = mimeMatch ? mimeMatch[1] : 'image/png';
        const ext = getImageExtensionFromMime(mimeType);
        const alt = meta.alt || '';
        return '![' + alt.replace(/\]/g, '') + '](images/' + id + '.' + ext + ')';
    });
}

function getImageExtensionFromMime(mimeType) {
    if (mimeType === 'image/png') return 'png';
    if (mimeType === 'image/jpeg') return 'jpg';
    if (mimeType === 'image/gif') return 'gif';
    if (mimeType === 'image/svg+xml') return 'svg';
    return 'png';
}

// Initialize
updateDisplay();
updateColors();
</script>

</body>
</html>


        </section>
        <div class="post-tags">
          
        </div>
      </div>

      
      
    </div>

    </article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2025  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>



</div>
    </body>
</html>
